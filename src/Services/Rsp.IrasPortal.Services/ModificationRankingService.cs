using Mapster;
using Rsp.IrasPortal.Application.Constants;
using Rsp.IrasPortal.Application.DTOs.CmsQuestionset;
using Rsp.IrasPortal.Application.DTOs.Requests;
using Rsp.IrasPortal.Application.DTOs.Responses;
using Rsp.IrasPortal.Application.Services;

namespace Rsp.IrasPortal.Services;

/// <summary>
/// Computes and persists modification change ranking and overall modification ranking,
/// orchestrating calls to CMS question set services and respondent answer services.
/// </summary>
/// <remarks>
/// This service:
/// - Computes per-change ranking from CMS journey metadata and respondent answers.
/// - Persists change-level computed values (modification type, category, review type).
/// - Rebuilds and updates overall modification ranking based on all changes.
/// </remarks>
/// <param name="cmsQuestionsetService">
/// The CMS question set service used to retrieve the modification journey, initial questions, and ranking.
/// </param>
/// <param name="respondentService">
/// The respondent service used to fetch stored answers for project records and modification changes.
/// </param>
/// <param name="projectModificationsService">
/// The project modifications service used to fetch and update modifications and their changes.
/// </param>
public class ModificationRankingService
(
    ICmsQuestionsetService cmsQuestionsetService,
    IRespondentService respondentService,
    IProjectModificationsService projectModificationsService
) : IModificationRankingService
{
    /// <summary>
    /// Recomputes the ranking for a single modification change and persists the computed values.
    /// </summary>
    /// <param name="modificationChangeId">The unique identifier of the modification change.</param>
    /// <param name="projectRecordId">The unique identifier of the project record.</param>
    /// <returns>A task representing the asynchronous operation.</returns>
    /// <remarks>
    /// This method:
    /// - Loads the change to identify its specific area of change.
    /// - Retrieves initial questions to determine applicability question visibility.
    /// - Calculates ranking using <see cref="CalculateChangeRanking(string, string, bool, Guid)"/>.
    /// - Persists updated fields via <see cref="IProjectModificationsService.UpdateModificationChange(ProjectModificationChangeRequest)"/>.
    /// </remarks>
    public async Task UpdateChangeRanking(Guid modificationChangeId, string projectRecordId)
    {
        // Load the specific change to discover its specific area of change; bail out on failure.
        var modificationChangeResponse = await projectModificationsService.GetModificationChange(modificationChangeId);
        if (!modificationChangeResponse.IsSuccessStatusCode || modificationChangeResponse.Content is null)
        {
            // No change found or service error; nothing to update.
            return;
        }

        var modificationChange = modificationChangeResponse.Content;

        // Fetch initial questions in order to determine whether applicability questions are shown for this area.
        var initialQuestionsResponse = await cmsQuestionsetService.GetInitialModificationQuestions();
        if (!initialQuestionsResponse.IsSuccessStatusCode || initialQuestionsResponse.Content is null)
        {
            // Without initial questions we cannot determine applicability; exit gracefully.
            return;
        }

        // Resolve the specific area metadata (to read ShowApplicabilityQuestions).
        var specificArea = initialQuestionsResponse.Content
            .AreasOfChange
            .SelectMany(a => a.SpecificAreasOfChange)
            .FirstOrDefault(s => s.AutoGeneratedId == modificationChange.SpecificAreaOfChange);

        var showApplicability = specificArea?.ShowApplicabilityQuestions ?? false;

        // Calculate the ranking for this single change using CMS journey + stored answers.
        var ranking = await CalculateChangeRanking
        (
            projectRecordId,
            modificationChange.SpecificAreaOfChange,
            showApplicability,
            modificationChangeId
        );

        // Map the change to an update request and augment with computed values.
        var modificationChangeRequest = modificationChange.Adapt<ProjectModificationChangeRequest>();

        modificationChangeRequest.UpdateRanking(ranking);

        // Save the updated change.
        await projectModificationsService.UpdateModificationChange(modificationChangeRequest);
    }

    /// <summary>
    /// Recomputes all change rankings for a modification, updates the overall ranking, and persists the modification.
    /// </summary>
    /// <param name="projectModificationId">The unique identifier of the project modification.</param>
    /// <param name="projectRecordId">The unique identifier of the project record.</param>
    /// <returns>A task representing the asynchronous operation.</returns>
    /// <remarks>
    /// This method:
    /// - Loads the modification and its changes.
    /// - For each change with valid area/specific area, recalculates ranking and enriches the change request.
    /// - Derives persisted strings, categorisation orders, and substantiality orders.
    /// - Calls <see cref="ProjectModificationRequest.UpdateOverAllRanking"/> to compute overall ranking.
    /// - Persists via <see cref="IProjectModificationsService.UpdateModification(ProjectModificationRequest)"/>.
    /// </remarks>
    public async Task UpdateOverallRanking(Guid projectModificationId, string projectRecordId)
    {
        // Fetch the modification; exit if missing or failed.
        var modificationResponse = await projectModificationsService.GetModification(projectModificationId);
        if (!modificationResponse.IsSuccessStatusCode || modificationResponse.Content is null)
        {
            return;
        }

        // Fetch all changes for the modification; exit on failure.
        var changesResponse = await projectModificationsService.GetModificationChanges(projectModificationId);
        if (!changesResponse.IsSuccessStatusCode || changesResponse.Content is null)
        {
            return;
        }

        // Fetch initial questions (to access area/specific area metadata such as applicability flag).
        var initialQuestionsResponse = await cmsQuestionsetService.GetInitialModificationQuestions();
        if (!initialQuestionsResponse.IsSuccessStatusCode || initialQuestionsResponse.Content is null)
        {
            return;
        }

        var initialQuestions = initialQuestionsResponse.Content;
        var projectModificationResponse = modificationResponse.Content;

        // Rebuild the full update request model from the response.
        // We'll add enriched change requests (with computed ranking + ordering) below.
        var projectModificationRequest = projectModificationResponse.Adapt<ProjectModificationRequest>();

        // For each change: recompute the ranking and attach enriched change request to the update payload.
        foreach (var change in changesResponse.Content.OrderByDescending(c => c.CreatedDate))
        {
            // Skip invalid entries (area/specific area required to compute ranking).
            if (change.AreaOfChange == Guid.Empty.ToString() || change.SpecificAreaOfChange == Guid.Empty.ToString())
            {
                continue;
            }

            // Locate the specific area metadata to determine applicability and ensure the journey exists.
            var area = initialQuestions.AreasOfChange.Find(a => a.AutoGeneratedId == change.AreaOfChange);
            var specificArea = area?.SpecificAreasOfChange.Find(s => s.AutoGeneratedId == change.SpecificAreaOfChange);
            if (specificArea is null) continue;

            // Compute ranking for the individual change.
            var ranking = await CalculateChangeRanking
            (
                projectRecordId,
                specificArea.AutoGeneratedId!,
                specificArea.ShowApplicabilityQuestions,
                change.Id
            );

            // Map the change to an update request and augment with computed values.
            var changeRequest = change.Adapt<ProjectModificationChangeRequest>();

            changeRequest.UpdateRanking(ranking);

            // Append the enriched change update to the overall modification update request.
            projectModificationRequest.ProjectModificationChanges.Add(changeRequest);
        }

        // Recalculate overall ranking from all enriched changes.
        projectModificationRequest.UpdateOverAllRanking();

        // Persist the updated modification with recomputed overall ranking.
        await projectModificationsService.UpdateModification(projectModificationRequest);
    }

    /// <summary>
    /// Calculates the ranking for a specific modification change using CMS journey metadata and respondent answers.
    /// </summary>
    /// <param name="projectRecordId">The unique identifier of the project record.</param>
    /// <param name="specificAreaOfChangeId">The specific area of change identifier driving the journey.</param>
    /// <param name="showApplicabilityQuestions">Indicates whether applicability questions are shown for this specific area.</param>
    /// <param name="modificationChangeId">The unique identifier of the modification change.</param>
    /// <returns>
    /// A task producing a <see cref="RankingOfChangeResponse"/> with computed fields such as modification type,
    /// categorisation, and review type. If unavailable, returns an empty response object.
    /// </returns>
    /// <remarks>
    /// - Fetches the CMS journey for the specific area.
    /// - If applicability questions are not shown, it derives NHS/HSC involvement from the project record.
    /// - Builds a <see cref="RankingOfChangeRequest"/> from metadata and answers and asks CMS to compute the ranking.
    /// </remarks>
    public async Task<RankingOfChangeResponse> CalculateChangeRanking
    (
        string projectRecordId,
        string specificAreaOfChangeId,
        bool showApplicabilityQuestions,
        Guid modificationChangeId
    )
    {
        // Fetch the CMS journey (sections/questions) tailored to the specific area of change.
        var journeyResponse = await cmsQuestionsetService.GetModificationsJourney(specificAreaOfChangeId);
        if (!journeyResponse.IsSuccessStatusCode || journeyResponse.Content is null)
        {
            // Cannot compute without journey metadata.
            return new RankingOfChangeResponse();
        }

        // When applicability questions are not required, derive NHS/HSC involvement from Project Record (IQA0004),
        // otherwise leave it to be inferred from the change answers.
        string nhsOrHscOrganisations = string.Empty;

        if (!showApplicabilityQuestions)
        {
            var projectRecordAnswersResponse =
                await respondentService.GetRespondentAnswers(projectRecordId, QuestionCategories.ProjectRecord);

            var prAnswers = projectRecordAnswersResponse.Content ?? [];

            var ans = prAnswers.FirstOrDefault(a => a.QuestionId == QuestionIds.NhsOrHscOrganisations);

            nhsOrHscOrganisations = ans?.SelectedOption switch
            {
                var x when x == QuestionAnswersOptionsIds.Yes => "Yes",
                _ => "No"
            };
        }

        // Load answers provided specifically for this change (used to map to ranking payload).
        var answersResponse = await respondentService.GetModificationChangeAnswers(modificationChangeId, projectRecordId);
        var answers = answersResponse.IsSuccessStatusCode ?
            (answersResponse.Content ?? []) :
            [];

        // Build the payload expected by CMS ranking endpoint by merging metadata + respondent answers.
        var rankingOfChangeRequest = BuildRankingOfChangeRequest
        (
            specificAreaOfChangeId,
            showApplicabilityQuestions,
            journeyResponse.Content,
            answers,
            nhsOrHscOrganisations
        );

        // Compute the ranking and return the content (or empty result on failure).
        var rankingResp = await cmsQuestionsetService.GetModificationRanking(rankingOfChangeRequest);

        return rankingResp.Content ?? new RankingOfChangeResponse();
    }

    /// <summary>
    /// Builds the <see cref="RankingOfChangeRequest"/> payload from CMS journey metadata and respondent answers.
    /// </summary>
    /// <param name="specificAreaOfChangeId">The identifier of the specific area of change.</param>
    /// <param name="applicability">Whether applicability questions are enabled for this specific area.</param>
    /// <param name="cms">The CMS question set response representing the journey metadata for the area.</param>
    /// <param name="respondentAnswers">The collection of respondent answers for the modification change.</param>
    /// <param name="nhsOrHscOrganisations">
    /// Forced NHS/HSC involvement indicator derived from the project record (e.g., "Yes" or "No") when applicability is disabled.
    /// </param>
    /// <returns>A fully populated <see cref="RankingOfChangeRequest"/> used to compute the ranking.</returns>
    private static RankingOfChangeRequest BuildRankingOfChangeRequest
    (
        string specificAreaOfChangeId,
        bool applicability,
        CmsQuestionSetResponse cms,
        IEnumerable<RespondentAnswerDto> respondentAnswers,
        string nhsOrHscOrganisations
    )
    {
        // Flatten questions for lookup by QuestionId (single place to search in all sections).
        var questions = cms.Sections.SelectMany(s => s.Questions).ToList();

        // Determine NHS involvement:
        // - If forced by Project Record (applicability disabled and PR says "Yes") then treat as involved.
        // - Otherwise, infer from the answer that matches the configured "NhsInvolvment" option text.
        QuestionModel? nhsInvolvementQuestion = null;

        if (nhsOrHscOrganisations == "Yes")
        {
            // Force NHS involvement by setting a non-null marker.
            nhsInvolvementQuestion = new QuestionModel();
        }
        else
        {
            nhsInvolvementQuestion = questions
                .SingleOrDefault
                (question =>
                    question.NhsInvolvment != null &&
                    IsAnswerTextSelected(respondentAnswers, question, question.NhsInvolvment));
        }

        // Determine Non-NHS involvement based on configured option text.
        var nonNhsQuestion = questions
            .SingleOrDefault(question =>
                question.NonNhsInvolvment != null &&
                IsAnswerTextSelected(respondentAnswers, question, question.NonNhsInvolvment));

        // Resolve additional metadata-driven questions used by ranking.
        var orgsAffectedQuestion = questions.SingleOrDefault(question => question.AffectedOrganisations);
        var additionalResourcesQuestion = questions.SingleOrDefault(question => question.RequireAdditionalResources);

        // True when we either forced NHS involvement or inferred it from answers.
        var isNhsInvolved = nhsInvolvementQuestion is not null;

        // NHS organisations affected:
        // - Forced to "All" when PR says "Yes" (applicability disabled),
        // - otherwise resolve the selected value from respondent answers.
        var nhsOrganisationsAffected = string.Empty;
        if (nhsOrHscOrganisations == "Yes")
        {
            nhsOrganisationsAffected = "All";
        }
        else
        {
            nhsOrganisationsAffected = GetSelectedAnswerText(respondentAnswers, orgsAffectedQuestion) ?? string.Empty;
        }

        // True when "Require additional resources" was answered "Yes".
        var nhsResourceImplications = string.Equals(
            GetSelectedAnswerText(respondentAnswers, additionalResourcesQuestion) ?? string.Empty,
            "Yes",
            StringComparison.OrdinalIgnoreCase);

        // Compose the final payload for CMS to compute the ranking.
        return new RankingOfChangeRequest
        {
            SpecificAreaOfChangeId = specificAreaOfChangeId,
            Applicability = applicability ? "Yes" : "No",
            IsNHSInvolved = isNhsInvolved,
            IsNonNHSInvolved = nonNhsQuestion is not null,
            NhsOrganisationsAffected = nhsOrganisationsAffected,
            NhsResourceImplicaitons = nhsResourceImplications
        };
    }

    /// <summary>
    /// Determines whether the provided answer text is selected for a question based on respondent answers.
    /// </summary>
    /// <param name="answers">The collection of respondent answers.</param>
    /// <param name="question">The CMS question to evaluate.</param>
    /// <param name="answerText">The target answer option text to check for selection.</param>
    /// <returns><c>true</c> if the answer option text is selected; otherwise, <c>false</c>.</returns>
    /// <remarks>
    /// This handles multi-select scenarios by resolving the selected option names from IDs and comparing case-insensitively.
    /// </remarks>
    private static bool IsAnswerTextSelected(IEnumerable<RespondentAnswerDto> answers, QuestionModel question, string answerText)
    {
        // Find the respondent answer matching the CMS question.
        var answer = answers.FirstOrDefault(x => x.QuestionId == question.Id);
        if (answer == null)
        {
            return false;
        }

        // Only process when the answer contains selected option IDs and CMS provided the options list.
        if (answer.Answers?.Count > 0 && question.Answers?.Any() == true)
        {
            // Translate selected option IDs to display names and check if any matches the target text.
            var selectedOptions = question.Answers.Where(opt => answer.Answers.Contains(opt.Id!)).Select(opt => opt.OptionName);
            return selectedOptions.Any(option => string.Equals(option, answerText, StringComparison.OrdinalIgnoreCase));
        }

        return false;
    }

    /// <summary>
    /// Retrieves the human-readable selected answer text for the given question from respondent answers.
    /// </summary>
    /// <param name="answers">The collection of respondent answers.</param>
    /// <param name="question">The CMS question to resolve the selected answer for.</param>
    /// <returns>
    /// The option name when a single option ID is selected and resolvable; otherwise the free-text answer;
    /// or <c>null</c> when the question is not answered.
    /// </returns>
    private static string? GetSelectedAnswerText(IEnumerable<RespondentAnswerDto> answers, QuestionModel? question)
    {
        // Quick guard: question metadata not available.
        if (question is null)
        {
            return null;
        }

        // Find the user's answer for the question.
        var selectedAnswer = answers.FirstOrDefault(x => x.QuestionId == question.Id);

        if (selectedAnswer == null)
        {
            // Not answered.
            return null;
        }

        // When an option ID is present, map it to its display name using CMS options collection.
        if (!string.IsNullOrWhiteSpace(selectedAnswer.SelectedOption) && question.Answers?.Any() == true)
        {
            return question.Answers.FirstOrDefault(opt => opt.Id == selectedAnswer.SelectedOption)?.OptionName;
        }

        return null;
    }
}